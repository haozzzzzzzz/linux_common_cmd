# 数据

Go提供两种分配原语，即内奸函数new和make。



## new分配

- 不会**初始化**内存，只会讲内存**置零**。`new(T)`会为类型为`T`的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为`*T`的值。用Go的术语来说，它返回一个指针，该指针指向新分配的，类型为T的零值。
- `new(File)`和`&File{}`是等价的。



## make分配

- 内建函数`make(T, args)`的目的不同于`new(T)`。它只用于创建切片、映射和信道，并返回类型为T（而非*T）的一个已初始化（而非置零）的值。出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们再使用前必须初始化。



## 数组

Go中数组：

- 数组是值。将一个数组赋予给另一个数组会赋值其所有元素。
- 特别地，若将某个数组传入某个函数，它将接收到该数组的一份副本而非指针。
- 数组的大小是其类型的一部分。类型`[10]int`和`[20]int`是不同的。



## 切片

切片是对数组进行封装，为数据序列提供了更通用、强大而方便的接口。除了矩阵变换这类需要明确维度的情况外，Go中的大部分数组变成都是通过切片来完成的。



## 映射

映射是方便而强大的内建数据结构。它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型，如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构及数组。切片不能用作映射键，因为它们的相等性还未定义。

- 若视图通过映射中不存在的键来取值，就会返回与改映射忠想的类型对应的零值。

- “逗号ok”惯用法。像map取值，返回值可有两个，`值，是否存在=map[键]`。在下面的例子中，若tz存在；seconds就会被赋予适当的值，且ok会被置为true。若不存在，seconds则会被置为零，而o会被置为false。

  ```go
  func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
  }
  ```

- 要删除映射中的某项，可使用内建函数delete。`delete(timeZone, "PDT")`